<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="/css/main.css">
        <link rel="stylesheet" href="/css/prism.css">
        <script src="/global JS files/prism.js"></script>
        <title>Объекты</title>
    </head>

    <p>
        <h1>Объекты</h1>
        <p>В JS есть 8 типов данных, семь из них называются примивными, так как содержат только оджно значение. Объекты же используют для хранения коллекций различных значений и более сложных сущностей. в JS объекты используются очень часто, это одна из основ языка.</p>
        <p>Объект можно представить в виде ящика с подписанными папками. Каждый элемент хранится в своей папке, на которой написан ключ. По ключу папку легко найти, удалить или добавить в нее что-либо.</p>

        <p>Пустой объект можно создать используя один из вариантов синтаксиса:</p>

        <pre><code class="lang-js">
            let user = new object(); // синтаксис "конструктор объекта"
            let user = {}; // синтаксис "литерал объекта или литеральная нотация"
        </code></pre>

        <hr>

        <h2>Литералы и свойста</h2>
        <p>При использовании литерального синтаксиса мы сразу можем поместить в объект несколько свойств в виде пар <em>"ключ:название"</em>:</p>

        <pre><code class="lang-js">
            let user = { // объект
                name: 'John', // под ключем 'name' хранится значение 'John'
                age: 30 // под ключом 'age'  хранится значение 30
            };
        </code></pre>

        <p>У каждого свойства есть ключ (также называемый "имя" или "идентификатор"). После имени свойства следует двоеточие ":", и затем указывается значение свойства. Если в объекте несколько свойств, то они перечисляются через запятую.</p>

        <p>В объекте <code class="lang-js">user</code> сейчас два свойста:</p>
        <ul>
            <li>свойство с именем<code class="lang-js">'name'</code> и значением<code class="lang-js">'John'</code></li>
            <li>свойство с именем<code class="lang-js">age</code> и значением<code class="lang-js">30</code></li>
        </ul>

        <p>Для обращения к свойствам используется запись «через точку»:</p>
        
        <pre><code class="lang-js">
            console.log(user.name); // John
            console.log(user.age); // 30
        </code></pre>

        <p>Для удаления свойства мы можем использовать оператор <code class="lang-js">delete</code>:</p>

        <pre><code class="lang-js">
            delete user.age;
        </code></pre>

        <p>Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:</p>
        <pre><code class="lang-js">
            let user = {
                name: 'John',
                age: 30,
                'likes birds': true
            };
        </code></pre>

        <p>Объект, объявленный через <code class="lang-js">const</code> может быть изменен. Так как защита от редактирования распространяется только на название объекта, мы можем менять его свойства.</p>

        <pre> <code class="lang-js">
            const user {
                name: 'John',
            };

            user.name = 'Pete';

            console.log(user.name); // Pete
        </code></pre>
        <hr>

        <h2>Квадратные скобки</h2>
        <p>Для свойств, имена которых состояит из несколькиз слов, доступ к значению через точку не работает. Потому что точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел пробелов, не начинался с цифр и не содержал специальные символы, кроме <code class="lang-js">$</code> и <code class="lang-js">_</code>. Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. В целом, этот способ сработает с любым именем свойства:</p>
        
        <pre><code class="lang-js">
            let = user{};

            user['likes birds'] = true;

            console.log(user['likes birds']);
        </code></pre>

        <p>Квадратные скобки позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:</p>

        <pre><code class="lang-js">
            let key = 'chocolate milk';

            user[key] = true; // user['chocolate milk'] = true;
        </code></pre>

        <p>здесь переменная <pre><code class="lang-js">key</code></pre> может быть вычислена во время выполнения кода или зависеть лт пользовательского ввода. После этого мы используем её для доступа к свойству. Это даёт нам большую гибкость, через точку мы не сможешь сделать нечто подобное.</p>
        <hr>

        <h3>Вычисляемые свойства</h3>

        <p>Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.</p>

        <pre><code class="lang-js">
            let fruit = prompt('which fruit put to bag?', '');
            let sum = prompt('summary', '');
            
            let bag = {
                fruit: [fruit + 'apple'],
                sum: [sum]
            };

            console.log(bag.fruit);
            console.log(bag.sum);
        </code></pre>

        <p>Смысл вычисляемого свойства прост: свойства <code class="lang-js">[fruit]</code> и <code class="lang-js">[sum]</code> будут взяты из одноименных переменных. Кроме того, в этом примере видно, что благодаря квадратным скобкам мы можем использовать более сложные выражения. <code class="lang-js">[fruit + 'apple']</code></p>

        <p>Аналогичный пример:</p>

        <pre><code class="lang-js">
            let fruit = 'banana'

            let bag = {};

            bag[fruit + 'apple'];
        </code></pre>

        <p>Квадратные скобки дают намного больше возможности, чем записи через точку. Они позволяют использовать любые имена свойств и переменные, но требуют более массивных конструкций кода.</p>

        <h3>Итог</h3>
        <p>В большистве случаев, когда имена свойств известны и просты, используется запись через точку. Если же нам нужно что-то сложное, то мы используем квадратные скобки.</p>
        <hr>

        <h2>Свойства из переменной</h2>

        <p>В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.</p>

        <pre><code class="lang-js">
            function makeUser (cont1, cont2) {
                return {
                    cont1: cont1,
                    cont2: cont2
                };
            }
            
            let user = makeUser('63455', 243556);
            
            console.log(user.cont1); // '63455'
        </code></pre>

        <p>Ниже будет тот же результат, благодарю возможности записи короткого свойства.</p>

        <pre><code class="lang-js">
            function makeUser (cont1, cont2) {
                return {
                    cont1,
                    cont2
                };
            }
            
            let user = makeUser('63455', 243556);
            
            console.log(user.cont1); // '63455'
        </code></pre>
        <hr>

        <h2>Ограничение на имена свойств</h2>
        <p>Ограничение на объявление переменной с использованием зарезервированных слов, не распространяется на свойства объекта.</p>

        <pre><code class="lang-js">
            let obj = {
                for: 1,
                let: 2,
                return: 3
              };
              
              alert( obj.for + obj.let + obj.return );  // 6
        </code></pre>

        <p>Все другие типы данных будут автоматически преобразованы к строке.</p>

        <pre><code class="lang-js">
            let obj = {
                0: "Тест" // то же самое что и "0": "Тест"
              };
              
              // обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
              alert( obj["0"] ); // Тест
              alert( obj[0] ); // Тест (то же свойство)
        </code></pre>

        <p>Есть небольшой подводный камень, связанный со специальным свойством __proto__. Мы не можем установить его в необъектное значение:</p>

        <pre><code class="lang-js">
            let obj = {};
            obj.__proto__ = 5; // присвоим число
            alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали)
        </code></pre>

    </body>
</html>