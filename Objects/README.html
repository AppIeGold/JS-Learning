<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="/css/main.css">
        <link rel="stylesheet" href="/css/prism.css">
        <script src="/global JS files/prism.js"></script>
        <title>Объекты</title>
    </head>

    <p>
        <h1>Объекты</h1>
        <p>В JS есть 8 типов данных, семь из них называются примивными, так как содержат только оджно значение. Объекты же используют для хранения коллекций различных значений и более сложных сущностей. в JS объекты используются очень часто, это одна из основ языка.</p>
        <p>Объект можно представить в виде ящика с подписанными папками. Каждый элемент хранится в своей папке, на которой написан ключ. По ключу папку легко найти, удалить или добавить в нее что-либо.</p>

        <p>Пустой объект можно создать используя один из вариантов синтаксиса:</p>

        <pre><code class="lang-js">
            let user = new object(); // синтаксис "конструктор объекта"
            let user = {}; // синтаксис "литерал объекта или литеральная нотация"
        </code></pre>

        <hr>

        <h2>Литералы и свойста</h2>
        <p>При использовании литерального синтаксиса мы сразу можем поместить в объект несколько свойств в виде пар <em>"ключ:название"</em>:</p>

        <pre><code class="lang-js">
            let user = { // объект
                name: 'John', // под ключем 'name' хранится значение 'John'
                age: 30 // под ключом 'age'  хранится значение 30
            };
        </code></pre>

        <p>У каждого свойства есть ключ (также называемый "имя" или "идентификатор"). После имени свойства следует двоеточие ":", и затем указывается значение свойства. Если в объекте несколько свойств, то они перечисляются через запятую.</p>

        <p>В объекте <code class="lang-js">user</code> сейчас два свойста:</p>
        <ul>
            <li>свойство с именем<code class="lang-js">'name'</code> и значением<code class="lang-js">'John'</code></li>
            <li>свойство с именем<code class="lang-js">age</code> и значением<code class="lang-js">30</code></li>
        </ul>

        <p>Для обращения к свойствам используется запись «через точку»:</p>
        
        <pre><code class="lang-js">
            console.log(user.name); // John
            console.log(user.age); // 30
        </code></pre>

        <p>Для удаления свойства мы можем использовать оператор <code class="lang-js">delete</code>:</p>

        <pre><code class="lang-js">
            delete user.age;
        </code></pre>

        <p>Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:</p>
        <pre><code class="lang-js">
            let user = {
                name: 'John',
                age: 30,
                'likes birds': true
            };
        </code></pre>

        <p>Объект, объявленный через <code class="lang-js">const</code> может быть изменен. Так как защита от редактирования распространяется только на название объекта, мы можем менять его свойства.</p>

        <pre> <code class="lang-js">
            const user {
                name: 'John',
            };

            user.name = 'Pete';

            console.log(user.name); // Pete
        </code></pre>
        <hr>

        <h2>Квадратные скобки</h2>
        <p>Для свойств, имена которых состояит из несколькиз слов, доступ к значению через точку не работает. Потому что точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел пробелов, не начинался с цифр и не содержал специальные символы, кроме <code class="lang-js">$</code> и <code class="lang-js">_</code>. Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. В целом, этот способ сработает с любым именем свойства:</p>
        
        <pre><code class="lang-js">
            let = user{};

            user['likes birds'] = true;

            console.log(user['likes birds']);
        </code></pre>

        <p>Квадратные скобки позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:</p>

        <pre><code class="lang-js">
            let key = 'chocolate milk';

            user[key] = true; // user['chocolate milk'] = true;
        </code></pre>

        <p>здесь переменная <pre><code class="lang-js">key</code></pre> может быть вычислена во время выполнения кода или зависеть лт пользовательского ввода. После этого мы используем её для доступа к свойству. Это даёт нам большую гибкость, через точку мы не сможешь сделать нечто подобное.</p>
        <hr>

        <h3>Вычисляемые свойства</h3>

        <p>Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.</p>

        <pre><code class="lang-js">
            let fruit = prompt('which fruit put to bag?', '');
            let sum = prompt('summary', '');
            
            let bag = {
                fruit: [fruit + 'apple'],
                sum: [sum]
            };

            console.log(bag.fruit);
            console.log(bag.sum);
        </code></pre>

        <p>Смысл вычисляемого свойства прост: свойства <code class="lang-js">[fruit]</code> и <code class="lang-js">[sum]</code> будут взяты из одноименных переменных. Кроме того, в этом примере видно, что благодаря квадратным скобкам мы можем использовать более сложные выражения. <code class="lang-js">[fruit + 'apple']</code></p>

        <p>Аналогичный пример:</p>

        <pre><code class="lang-js">
            let fruit = 'banana'

            let bag = {};

            bag[fruit + 'apple'];
        </code></pre>

        <p>Квадратные скобки дают намного больше возможности, чем записи через точку. Они позволяют использовать любые имена свойств и переменные, но требуют более массивных конструкций кода.</p>

        <h3>Итог</h3>
        <p>В большистве случаев, когда имена свойств известны и просты, используется запись через точку. Если же нам нужно что-то сложное, то мы используем квадратные скобки.</p>
        <hr>

        <h2>Свойства из переменной</h2>

        <p>В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.</p>

        <pre><code class="lang-js">
            function makeUser (cont1, cont2) {
                return {
                    cont1: cont1,
                    cont2: cont2
                };
            }
            
            let user = makeUser('63455', 243556);
            
            console.log(user.cont1); // '63455'
        </code></pre>

        <p>Ниже будет тот же результат, благодарю возможности записи короткого свойства.</p>

        <pre><code class="lang-js">
            function makeUser (cont1, cont2) {
                return {
                    cont1,
                    cont2
                };
            }
            
            let user = makeUser('63455', 243556);
            
            console.log(user.cont1); // '63455'
        </code></pre>
        <hr>

        <h2>Ограничение на имена свойств</h2>
        <p>Ограничение на объявление переменной с использованием зарезервированных слов, не распространяется на свойства объекта.</p>

        <pre><code class="lang-js">
            let obj = {
                for: 1,
                let: 2,
                return: 3
              };
              
              alert( obj.for + obj.let + obj.return );  // 6
        </code></pre>

        <p>Все другие типы данных будут автоматически преобразованы к строке.</p>

        <pre><code class="lang-js">
            let obj = {
                0: "Тест" // то же самое что и "0": "Тест"
              };
              
              // обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
              alert( obj["0"] ); // Тест
              alert( obj[0] ); // Тест (то же свойство)
        </code></pre>

        <p>Есть небольшой подводный камень, связанный со специальным свойством __proto__. Мы не можем установить его в необъектное значение:</p>

        <pre><code class="lang-js">
            let obj = {};
            obj.__proto__ = 5; // присвоим число
            alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали)
        </code></pre>
        <hr>

        <h2>Проверка существования свойства, оператор in</h2>

        <p>В js можно получить доступ к свойству объекта, даже если этого свойства не существует. Просто мы получим <code class="lang-js">undefined</code>.</p>

        <pre><code class="lang-js">
            let user = {};

            console.log(user.noSuchProperty === undefined); // undefined
        </code></pre>

        <p>Для этого есть специальный оператор <code class="lang-js">in</code>. Его синтаксис: <code class="lang-js">'key' in object</code>.</p>

        <pre><code class="lang-js">
            let user = {name: 'Vasya', age: 25};

            console.log('age' in user); // true
            console.log('name' in user); // true
            console.log('weight' in user); // false
        </code></pre>

        <p>Если мы опускаем кавычки слева от <code class="lang-js">in</code>, это значит, что мы указываем переменную, в которой находится имя свойства.</p>
        
        <pre><code class="lang-js">
            let user = { age: 30 };

            let key = "age";
            alert( key in user ); // true, имя свойства было взято из переменной key
        </code></pre>

        <p>В целом, можно всегда использовать способ с <code class="lang-js">undefined</code>, но есть случай, когда он не подойдет. Это когда свойство существует, но содержит значение <code class="lang-js">undefined</code>:</p>

        <pre><code class="lang-js">
            let obj = {
                test: undefined
            };

            console.log(obj.test); // undefined
            console.log('test in obj'); // true
        </code></pre>
        <hr>

        <h2>Цикл for in</h2>

        <p>Для перебора всех свойств объекта используется цикл <b>for in</b>.</p>

        <pre><code class="lang-js">
            for (key in object) {
                // тело цикла выполняется для каждого свойства объекта
            }
        </code></pre>

        <p></p>

        <pre><code class="lang-js">
            let user = {
                name: 'Vasya',
                age: 25,
                isAdmin: true
            };
            
            for (let prop in user) {
                console.log(prop); // ключи
                console.log(user[prop]); // значения ключей
            }
        </code></pre>
        <hr>

        <h3>Упорядочение свойств объекта</h3>
        <p>Если мы будем в цикле перебирать все свойства ообъекта, получим ли мы их в том же порядке, в котором мы их добавляли? можем ли мы на это рассчитывать?</p>
        <p>Свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.</p>

        <pre><code class="lang-js">
            let codes = {
                '7': 'Россия',
                '41': 'Швейцария',
                '44': 'Великобритания',
                '1': 'США',
            };

            for (let code in codes) {
                console.log(code);
                console.log(codes[code]);
            }
        </code></pre>

        <p>При запуске кода видно, что коды идут в порядке возрастания, так как они являются целыми числами.</p>
        <h4 style="margin-bottom: -10px;">Целочисленное свойство</h4>
        <p> Это строка, которая может быть преобразована в целое число и обратно без изменений. То есть, <code class="lang-js">'49'</code> это целочисленное имя свойства, потому что если его преобразовать в тип <code class="lang-js">number</code>, а затем обратно в <code class="lang-js">string</code>, то оно не изменится. А вот например <code class="lang-js">'+49'</code> или <code class="lang-js">'1.2'</code> таковыми не являются.</p>

        <pre><code class="lang-js">
            console.log( String(Math.trunc(Number('49'))) ); // '49' - целочисленное
            console.log( String(Math.trunc(Number('+49'))) ); // '49' - не целочисленное
            console.log( String(Math.trunc(Number('1.2'))) ); // '1' - не целочисленное
        </code></pre>

        <p>Если ключи не целочисленные, то они перебираются в поряке создания, например:</p>

        <pre><code class="lang-js">
            let user = {
                name: 'Vasya',
                age: 35,
            };

            user.isAdmin = true;

            for (let prop in user) {
                console.log(prop);
            }
        </code></pre>

        <p>Таким образом, чтобы решить нашу проблему с телефонными кодами, мы можем схитрить, сделав коды не целочисленными свойствами. Добавления знака <code class="lang-js">'+'</code> перед каждым кодом будет достаточно. </p>
        
        <pre><code class="lang-js">
            let codes = {
                '+7': 'Россия',
                '+41': 'Швейцария',
                '+44': 'Великобритания',
                '+1': 'США',
            };

            for (let code in codes) {
                console.log(code);
                console.log(codes[code]);
            } // 7, 41, 44, 1
        </code></pre>
        <hr>

        <h2>Итог</h2>
        <p>Объекты - ассоциативные массивы с рядом дополнительных возможностей. Они хранят свойства (пары: ключ-название), где:</p>
        <ul>   
            <li>Ключи свойств должны быть строками или символами (обычно строками)</li>
            <li>Значения могут быть любого типа.</li>
        </ul>
        <p>Чтобы получить доступ к свойству, мы можем использовать:</p>
        <ul>
            <li>Запись через точку: <code class="lang-js">obj.property</code>.</li>
            <li>Квадратные скобки: <code class="lang-js">obj['property']</code>. А если мы хотим взять ключ из переменной: <code class="lang-js">obj[property]</code>. </li>
        </ul>
        <p>Дополнительные операторы:</p>
        <ul>
            <li>Удаление свойства: <code class="lang-js">delete obj.prop</code>.</li>
            <li>Проверка существования свойства: <code class="lang-js">'key' in obj</code>.</li>
            <li>Перебор свойств объекта: цикл for <code class="lang-js">for (let key in obj)</code>.</li>
        </ul>
        <p>То, что изучалось в этой главе, называется простым объектом <b>'plain object'</b> или просто  <code class="lang-js">object</code>.</p>
        <p>В js есть много других типов объектов:</p>
        <ul>
            <li> <code class="lang-js">Array</code> для хранения упорядоченных коллекций данных.</li>
            <li> <code class="lang-js">Date</code> для хранения информации о дате и времени.</li>
            <li> <code class="lang-js">Error</code> для хранения информации об ошибке.</li>
            <li> ...И тд.</li>
        </ul>
        <p>У них есть свои особенности, которые мы изучим позже. Иногда люди говорят что-то вроде «тип данных Array» или «тип данных Date», но формально они не являются отдельными типами, а относятся к типу данных Object. Они лишь расширяют его различными способами.</p>
        <hr>

        <h1>Копирование объектов и ссылки</h1>
        <p>Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются по ссылке, а примитивы, как целое значение, у них создается копия.</p>

        <h2>Клонирование и объединение, Object.assign</h2>
        <p>Как правило, зачастую хватает копирования по ссылке, но если сли надо сделать копию объекта, то нужно создать новый объект и воспроизвести структуру существующего, перебрав его свойства и скопировав их на примитивном уровне.</p>

        <pre><code class="lang-js">
            let user = {
                name: 'Vasya',
                age: 30
            };

            let clone = {};

            for (let key in user) {
                clone[key] = user[key];
            }

            clone.name = 'Pete';

            console.log(user.name);
        </code></pre>

        <P>Или можно использовать метод <b>Object.assign</b></P>

        <pre><code class="lang-js">
            Object.assign(dest, [src1, src2, src3...])
        </code></pre>

        <ul>
            <li>Первый аргумент <code class="lang-js">dest</code> - целевой объект.</li>
            <li>Остальные аргументы<code class="lang-js">src1, ...,srcN</code> являются исходными объектами</li>
            <li>Метод копирует свойства всех исходных объектов<code class="lang-js">src1, ..., srcN</code>в целевой объект<code class="lang-js">dest</code>. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.</li>
            <li>Возвращает объект<code class="lang-js">dest</code>.</li>
        </ul>

        <p>Можно использовать его для объединения нескольких объектов в один:</p>

        <pre><code class="lang-js">
            let user = {name: 'John'};

            let permission1 = {canView: true};
            let permission2 = {canEdit: true};

            Object.assign(user, permission1, permission2);
        </code></pre>
        
        <p>Если скопированное имя свойства уже существует, оно будет перезаписано:</p>

        <pre><code class="lang-js">
            let user = {name: 'Vasya'};

            Object.assign(user, {name: 'John'});

            console.log(user.name); // 'John'
        </code></pre>

        <p>Мы также можем использовать <code class="lang-js">Object.assign</code> для замены цикла<code class="lang-js">for..in</code> для простого клонирования:</p>
        
        <pre><code class="lang-js">
            let user = {
                name: 'Vasya',
                age: 30
            }

            let clone = Object.assign({}, user);
        </code></pre>

        <p>Он копирует все свойства <code class="lang-js">user</code> в пустой объект и возвращает его.</p>
        <hr>

        <h2>Вложенное клонирование</h2>
        <p>Свойства могут быть ссылками на другие объекты</p>

        <pre><code class="lang-js">
            let user = {
                name: 'Vasya',
                sizes: {
                    height: 182,
                    width: 50
                }
            };

            console.log(user.sizes.height);
        </code></pre>
        

        <p>Недостаточно будет просто скопировать <code class="lang-js">Clone.sizes = user.sizes,</code>, потму что <code class="lang-js">user.sizes</code> - это объект, он будет скопирован по ссылке. Таким образом, <code class="lang-js">clone</code> и <code class="lang-js">user</code> будут иметь общий объект <code class="lang-js">sizes</code>.</p>

        <pre><code class="lang-js">
            let user = {
                name: "John",
                sizes: {
                  height: 182,
                  width: 50
                }
              };
              
              let clone = Object.assign({}, user);
              
              alert( user.sizes === clone.sizes ); // true, тот же объект
              
              // user и clone обладают общим свойством sizes
              user.sizes.width++;       // изменяем свойства в первом объекте
              alert(clone.sizes.width); // 51, видим результат в другом
        </code></pre>

        <p>Чтобы исправить это, мы должны использовать цикл клонирования, который проверяет каждое значение <code class="lang-js">user[key]</code> и, если это объект, тогда также копирует его структуру. Это называется <b>глубоким клонированием</b>.</p>
        
        <p>Его можно реализовать используя рекурсию. Или, чтобы не изобретать велосипел заново, возьмите готовую реализацию, например <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(value)</a> из библиотеки js <a href="https://lodash.com/">lodash</a>.</p>
        <hr>

        <h2>Итог</h2>
        <p>Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не значение объекта, а ссылку (адрес в памяти) на это значение. Таким образом, копирование такой переменной или передача ее в качестве аргумента функции копирует эту ссылку, а не сам объект.</p>

        <p>Все операции с использованием скопированных ссылок (например, добавление/удаление свойств) выполняются с одним и тем же объектом.</p>

        <p>Чтобы создать реальную копию, мы можем использовать <code class="lang-js">Object.assign</code> для так называемой поверхностной копии (вложенные объекты копируются по ссылке) или функцию глубокого клонирования, такую как <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(value)</a>.</p>
        <hr>

        <h2>Методы объекта, 'this'</h2>
        <p>Объекты обычно создаются, чтобы представлять сущности реального мира, будь то пользователи, заказы и так далее:</p>
        
        <pre><code class="lang-js">
            let user = {
                name: 'Vasya',
                age: 25
            };
        </code></pre>

        <p>И так же, как и в реальном мире, пользователь может совершать действия: выбирать что-то из корзины покупок, авторизовываться, выходить из системы, оплачивать и тд.</p>
        
        <hr>

        <h3>Примеры методов</h3>
        <p>Для начала давайте нучим нашего пользователя здороваться:</p>

        <pre><code class="lang-js">
            let user = {
                name: 'Vasya',
                age: 25
            }

            user.sayHi = function() {
                console.log('hello!');
            };

            user.sayHi(); //hello!
        </code></pre>

        <p>Здесь мы просто использовали функциональное выражение, чтобы создать функцию приветствия, и присвоили её свойству <code class="lang-js">user.sayHi</code> нашего объекта. Затем мы можем вызвать её как <code class="lang-js">user.sayHi()</code>. Теперь пользователь может говорить.</p>
        <p>Можно использовать заранее объявленную функцию, в качестве метода:</p>

        <pre><code class="lang-js">
            let user = {
                name: 'Vasya',
                age: 25
            }

            function sayHi() {
                console.log('hello!');
            }

            user.sayHi = sayHi();

            user.sayHi(); //hello!
        </code></pre>

        <h4>Сокращенная запись метода</h4>

        <pre><code class="lang-js">
            let user = {
                name: 'Vasya',
                age: 25,
                sayHi() {
                    console.log('hello!')
                }
            }

            user.sayHi(); //hello!
        </code></pre>

        <h2>Ключевое слово 'this' в методах</h2>
        <p></p>
    </body>
</html>